Я не успел доделать адаптив и оптимизацию, так как исчерпал лимит запросов API на 1 день
(а без апи практически ничего нет на экране и невозможно протестировать). Это из-за того, что оставил
все на последние дни (можете по коммитам отследить все). В ответах могут
быть грамматические ошибки, я сегодня не спал и очень сонный. 
Если я не пройду, хотел бы получить фидбек (свои ошибки и минусы,
чтобы исправить их потом). Желаю вам удачи. Пока

Вопрос:
Как вы можете описать процесс распространения событий в
JavaScript (Event Propagation)? Расскажите о его основных фазах.
Какие есть способы применения знаний о фазах
рааспространения событий на практике?

Ответ: 
1 фаза погружения; 2 фаза достижения; 3 фаза высплития
Честно сказать, я редко использую первую фазу в разработке,
еще не было нужды, но вторую и третью фазу часто использую.
Вторая фаза основная во front-end разработке, про него думаю
не нужно ничего говорить. Тертью фазу открывает такой метод
как "делегировании событий" и он Ооочень полезен и я часто
его использовал, а сейчас не очень часто. Ну и еще знаю, что
нельзя обработать отдельно вторую фазу, при её достижении вызываются
все обработчики: и на всплытие, и на погружение. 
(не встречаются пока задачи для этого).  

Вопрос:
Расскажите, что такое Promise в JavaScript, как он работает, какие
основные состояния у него бывают? Каким еще способомможно
обработать асинхронный код? Какую роль в асинхронности играет
событийный цикл (Event Loop)?

Ответ:
Промис - объект. Этот объект используется только в асинхронности.
Алгоритм работы промиса: Объект (промис) ждет, пока функция (executor)
закончит свое выполнение и в конце вызовит одну из двух функций, которые
js сам предоставляет: reject, resolve. После меняет свое состояние
(внутренне свойство state) из "pending" в "fulfilled" или "rejected" в
зависимости, какая функция была вызвана и так же изменится результат
(внутренне свойство result) либо то, что вернула функция "reject"
(обычно это объект ошибки), либо любой другое значение в случае с 
функцией "resolve". Начальное состояние у объекта промис: state: pending
result: undefined. Если ничего не вызвать начальное так и останется неизмененным.
До промисов люди использовали колбэки ими и сейчас можно обработать
асинхронный код.
Event Loop решает, в каком порядке код будет выполняться. Если во время выполнение
какого-либо кода у нас завершается settimeout или любой асинхронный код,
то он становится в очередь и будет выполнен только тогда, когда выполнится
текущий код, вся очередь микро задч и уже после пойдет выполнение кода
settimeout и отрисовка на странице.
Алгоритм таков:
1 - одна макро задача
2 - вся очередь микро задача
3 - отрисовка
4 - и циклично с первого по 3 пункт


Вопрос:
Что такое ООП, и какие его ключевые принципы вы могли бы
описать? При объяснении приводите примеры. Максимально
подробно расскажите о том, как ООП реализовано в JavaScript.

Ответ: ООП - объектно ориентированное программирование. 
ключевые принципы:
1 - инкапсуляция - скрытие внутренних деталей и облегчение
    использования. Например: 
    class Person {
      #name;

      constructor(name) {
        this.#name = name; // инициализация приватного свойства
      }

      // метод для доступа к приватному свойству
      getName() {
        return this.#name;
      }

      // метод для изменения приватного свойства
      setName(newName) {
        this.#name = newName;
      }
    }

const person = new Person("Alice");

person.getName(); // Alice
person.setName("Bob");
person.getName(); // Bob

person.#name; // Произойдет ошибка

2 - полиморфизм - позволяет использовать один интерфейс для
    разных типов объектов. Пример:
    метод draw() у классов Circle и Square ведёт себя по-разному,
    но вызывается одинаково.

3 - наследование - позволяет создавать новый класс на основе
    существующего, наследуя его свойства и методы. Пример:
    класс Rabbit наследует свойства и методы класса Animmal.

для начало. В JS все объекты кроме примитивов
(хотя для кроме null, undefined создаются врменные объекты обертки).
JS использует прототипное наследование. Пример: к некоторым свойствам
все равно можно будет сослаться даже если объект имеет такой вид "{}".
Если свойства внутри объекта нет, то JS будет его искать в object.__proto__
(прототипе) и если даже в прототипе нет, то будет искать в прототипе прототипа
и т.д, пока не найдет свойство или undefined. Прототипы можно полность менять
(но нужно работать с этим осторожно, ломает оптимизацию и не только) или частично.
Можно сразу создать объект с конкретным прототипов используя метод Object.create().
Но с появлением классов создание объектов и наследование стало проще, но
под капотом ничего не поменялось. Теперь можно наследовать с помощью extend,
три года назад появился синтаксис приватных свойств "#" (инкапсуляция).
А полиморфизм можно осуществлять через переопределение методов класса


Вопрос:
Опишите максимально детально, как браузер обрабатывает URL,
начиная с момента его ввода в адресную строку и заканчивая
отображением страницы. Какие технологии позволяют ускорить
процесс? Какие проблемы (безопастность, междоменное
взаимодействие) могут возникать в процессе?

Ответ:
Когда мы ищем веб-сайт (вводим его в адресную строку и нажимаем энтер),
то браузер:
1 - ищет фактический адрес этого веб сайта в DNS. Возьмем например сайт
    https://www.youtube.com. Его фактический адрес не www.youtube.com, а набор
    цифр: 74.125.142.190. А www.youtube.com это DNS.
2 - отправляет запрос на сервер с просьбой отправить копию веб сайта. А общаются
    клиент и сервер через протокол http(s). https более защищенный и рекомендуемый протокол
3 - А данные отправляются через  tcp - протокол управления передачи и ip межсетевой протокол.
    Именно они определяют, как данные отправляются в интернете.
4 - если сервер одобряет запрос, то отправляет файлы сайта в браузер в
    виде небольших фрагментов, которые называются пакетами данных  
5 - браузер собирает эти фрагменты в целую веб-страницу и отображает
5.1 - бразуер получает html и обрабатывает его, превращая DOM
5.2 - некоторые элементы html требуют новых запросов http(s) (изображения, стили и т.д)
5.3 - бразуер обрабатывает css и сортирует разыне правила CSS по разным "корзинам"
       в зависимости от того, к каким HTML-элементам они относятся, затем применяет эти
       стили для соответствующих элементов
5.4 - происходит отрисовка (визуальное отображение страницы отображается на экране)
5.5 - после обработки CSS любой JavaScript код, на странице анализируется, интерпретируется,
      компилируется и выполняется. Это происходит до завершения рендеринга страницы.

оптимизация:
1 - атрибуты async/defer, code-splitting, dynamic import: уменьшают время блокировки парсера и основной поток.
2 - lazy loading изображений: уменьшает количество одновременно загружаемых ресурсов.
3 - рендеринг на стороне сервера SSR: быстрее FCP, особенно для динамического контента.

проблемы:
1 - XSS
2 - CSRF
3 - CORS 
4 - Clickjacking